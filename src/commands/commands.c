/*
This file is part of JazzInSea.

JazzInSea is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

JazzInSea is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
JazzInSea. If not, see <https://www.gnu.org/licenses/>.
*/

#include "ai/eval_t.h"
#include "ai/evaluation.h"
#include "board/pos_t.h"
#include "board/status_t.h"
#include "commands/globals.h"
#include "io/fen.h"
#include "io/pp.h"
#include "move/generation.h"
#include "move/make_move.h"
#include "move/move_t.h"

#include <bits/types/siginfo_t.h>
#include <getopt.h>
#include <inttypes.h>
#include <signal.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

void make_automove() {
  // Check if the current player should be automoved.
  if (game_state.turn ? !global_options.white_automove
                      : !global_options.black_automove)
    return;

  // Check if the game ended.
  if (game_state.status != NORMAL) {
    io_error();
    pp_f("error: could not automove, game ended\n");
    io_info();
    pp_f("%s\n", board_status_text(game_state.status));

    global_options.white_automove = false;
    global_options.black_automove = false;
    return;
  }

  // Select one of the moves generated by the AI and make move.
  io_info();
  pp_f("automove...\n");

  move_t best_moves[256];
  evaluate(&game_state, &game_history, global_options.ai_depth,
           global_options.ai_time, global_options.ai_tt_size, best_moves);
  do_move(&game_state, &game_history, random_move(best_moves));

  io_info();
  pp_f("done automove\n");
  pp_board(game_state.board);

  make_automove();
}

#define command_define(name, simple, full)                                     \
  const char *command_##name##_simple = simple;                                \
  const char *command_##name##_full = full;                                    \
  bool command_##name(int argc, char **argv)

command_define(loadfen, "Load a board position using FEN",
               "Usage: loadfen FEN\n"
               "   or: loadfen PATH -f\n"
               "\n"
               "Load a board configuration from FEN string.\n"
               "\n"
               "  -f            Load FEN from PATH\n") {

  bool from_file = false;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "f");
    switch (c) {
    case '?':
      return false;
    case 'f':
      from_file = true;
      break;
    case -1:
      if (optind >= argc) {
        io_error();
        pp_f("error: 'loadfen' requires an argument\n");
        return false;
      }

      if (from_file) {
        if (!load_fen_from_path(argv[optind], &game_state, &game_history)) {
          io_error();
          pp_f("error: could not load FEN string from file\n");
          return false;
        }
      } else {
        if (!load_fen_string(argv[optind], &game_state, &game_history)) {
          io_error();
          pp_f("error: could not load FEN string\n");
          return false;
        }
      }
      io_info();
      pp_board(game_state.board);
      return true;
    }
  }
}

command_define(savefen, "Print the board position FEN",
               "Usage: savefen [OPTION]...\n"
               "\n"
               "Print the current board configuration.\n"
               "\n"
               "  -f PATH       Save the FEN to PATH\n") {

  bool to_file = false;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "f");
    switch (c) {
    case '?':
      return false;
    case 'f':
      to_file = true;
      break;
    case -1:
      if (to_file) {
        if (!save_fen_to_path(argv[optind], &game_state)) {
          io_error();
          pp_f("error: could not load FEN string from file\n");
          return false;
        }
      } else {
        char buffer[256];
        get_fen_string(buffer, &game_state);
        io_basic();
        pp_f("%s\n", buffer);
      }
      return true;
    }
  }
}

command_define(show, "Print the current board position",
               "Usage: show [OPTION]...\n"
               "\n"
               "Print the current board position.\n"
               "\n"
               "  -h            Print the hash value of the board instead\n"
               "  -i            Print the island bitboard table instead\n"
               "  -[PNpn]       Print the piece bitboard table instead\n") {

  enum { BOARD, HASH, BITBOARD } show_type = BOARD;
  uint64_t bitboard = 0;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "bhiPNpn");
    switch (c) {
    case '?':
      return false;
    case -1:
      goto end_of_parsing;
    case 'h':
      show_type = HASH;
      break;
    case 'i':
      show_type = BITBOARD;
      bitboard = game_state.islands_bb;
      break;
    case 'P':
      show_type = BITBOARD;
      bitboard = game_state.pieces_bb[0];
      break;
    case 'N':
      show_type = BITBOARD;
      bitboard = game_state.pieces_bb[1];
      break;
    case 'p':
      show_type = BITBOARD;
      bitboard = game_state.pieces_bb[2];
      break;
    case 'n':
      show_type = BITBOARD;
      bitboard = game_state.pieces_bb[3];
      break;
    }
  }

end_of_parsing:
  switch (show_type) {
  case BOARD:
    io_basic();
    pp_board(game_state.board);
    return true;
  case HASH:
    io_basic();
    pp_f("%lx\n", game_state.hash);
    return true;
  case BITBOARD:
    io_basic();
    pp_bitboard(bitboard);
    return true;
  }

  // Dummy return
  return false;
}

command_define(makemove, "Make a move",
               "Usage: makemove MOVE\n"
               "\n"
               "Try to make MOVE if it is a valid move.\n") {

  if (argc < 2) {
    io_error();
    pp_f("error: makemove requires MOVE argument\n");
    return false;
  }

  move_t move;
  if (!string_to_move(argv[1], game_state.board, &move)) {
    io_error();
    pp_f("error: invalid move notation '%s'\n", argv[1]);
    return false;
  }

  move_t moves[256];
  generate_moves(&game_state, moves);

  for (int i = 0; is_valid_move(moves[i]); i++) {
    if (compare_move(moves[i], move)) {
      do_move(&game_state, &game_history, move);
      generate_moves(&game_state, moves);
      make_automove();
      return true;
    }
  }

  io_error();
  pp_f("error: invalid move\n");
  return false;
}

command_define(undomove, "Undo the last move in history",
               "Usage: undomove\n"
               "\n"
               "Undo the last move in history, if there exists one.\n") {

  if (!game_history.size) {
    io_error();
    pp_f("error: no previous move\n");
    return false;
  }

  undo_last_move(&game_state, &game_history);
  return true;
}

command_define(status, "Print the current board status",
               "Usage: status\n"
               "\n"
               "Print the current board status.\n") {

  io_basic();
  pp_f("%s\n", board_status_text(game_state.status));
  return true;
}

command_define(allmoves, "Print the available moves on the current board",
               "Usage: allmoves\n"
               "   or: allmoves POS\n"
               "\n"
               "Print available moves on the current board.\n"
               "If given, only print moves originating from POS.\n"
               "Otherwise print all.\n") {

  move_t moves[256];
  generate_moves(&game_state, moves);

  if (argc == 2) {
    // If POS is given, parse it.
    pos_t position;
    if (!string_to_position(argv[1], &position)) {
      io_error();
      pp_f("error: invalid position '%s'\n", argv[1]);
      return false;
    }

    // Filter the moves array.
    size_t length = 0;
    for (size_t i = 0; is_valid_move(moves[i]); i++) {
      if (moves[i].from == position)
        moves[length++] = moves[i];
    }
    moves[length] = MOVE_INV;

  } else if (argc > 2) {
    io_error();
    pp_f("error: allmoves takes at most 1 arguments\n");
    return false;
  }

  io_basic();
  pp_moves(moves);
  pp_f("\n");

  return true;
}

command_define(descmove, "Describe move",
               "Usage: descmove MOVE [OPTION]...\n"
               "\n"
               "Print the 'from', 'to' and 'capture' positions of MOVE.\n"
               "If no captures were performed, print '-' for 'capture'.\n"
               "\n"
               "NOTE: This command does not check if MOVE is an available move \n"
               "in the current position\n"
               "\n"
               "  -i            Print square indexes instead of positions\n") {

  bool index = false;
  move_t move;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "i");
    switch (c) {
    case -1:
      goto end_of_parsing;
    case '?':
      break;
    case 'i':
      index = true;
      break;
    }
  }

end_of_parsing:

  if (optind == argc) {
    io_error();
    pp_f("error: descmove requires POS argument\n");
    return false;
  }

  if (!string_to_move(argv[optind], game_state.board, &move)) {
    io_error();
    pp_f("error: invalid move '%s'\n", argv[optind]);
    return false;
  }

  io_basic();
  if (index) {
    pp_f("%u %u ", move.from, move.to);
  } else {
    pp_position(move.from);
    pp_f(" ");
    pp_position(move.to);
    pp_f(" ");
  }

  if (!is_capture(move)) {
    pp_f("-");
  } else {
    pp_position(move.capture);
  }
  pp_f("\n");

  return true;
}

command_define(
    automove, "Set or unset the automove flag",
    "Usage: automove [OPTION]...\n"
    "\n"
    "Set the automove flag for both players. When a players automove flag is "
    "on and it is their move to play, the AI automatically generates and plays "
    "a random move.\n"
    "\n"
    "  -d            Unset the flags instead of setting them\n"
    "  -w            Set or unset only the white players automove flag\n"
    "  -b            Set or unset only the black players automove flag\n") {

  bool set = true;
  enum { WHITE, BLACK, BOTH } color = BOTH;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "dwb");
    switch (c) {
    case -1:
      goto end_of_parsing;
    case '?':
      break;
    case 'd':
      set = false;
      break;
    case 'w':
      color = WHITE;
      break;
    case 'b':
      color = BLACK;
      break;
    }
  }

end_of_parsing:
  if (color == WHITE || color == BOTH)
    global_options.white_automove = set;

  if (color == BLACK || color == BOTH)
    global_options.black_automove = set;

  make_automove();
  return true;
}

command_define(playai, "Make a random move generated by AI",
               "Usage: playai\n"
               "\n"
               "Make a random move generated by AI.\n") {

  // Check if the game ended.
  if (game_state.status != NORMAL) {
    io_error();
    pp_f("error: could not play any moves, game ended\n");
    return false;
  }

  // Select one of the moves generated by the AI and make move.
  io_info();
  pp_f("playing...\n");

  move_t best_moves[256];
  evaluate(&game_state, &game_history, global_options.ai_depth,
           global_options.ai_time, global_options.ai_tt_size, best_moves);
  do_move(&game_state, &game_history, random_move(best_moves));

  io_info();
  pp_f("done\n");

  make_automove();
  return true;
}

command_define(
    evaluate, "Evaluate the board and print evaluation information",
    "Usage: evaluate [OPTION]...\n"
    "\n"
    "Evaluate the board and print the best moves and the evaluation score.\n"
    "\n"
    "  -r            Select and print one of the best moves\n"
    "  -l            Print the list of generated moves only\n"
    "  -e            Print the evaluation score only\n") {

  enum { LIST, RANDOM_MOVE, EVAL_TEXT, FULL } evaluation_type = FULL;

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "erl");
    switch (c) {
    case '?':
      return false;
      break;
    case 'r':
      evaluation_type = RANDOM_MOVE;
      break;
    case 'l':
      evaluation_type = LIST;
      break;
    case 'e':
      evaluation_type = EVAL_TEXT;
      break;
    case -1:
      goto end_of_parsing;
    }
  }

end_of_parsing:
  // Check if the game ended.
  if (game_state.status != NORMAL) {
    io_error();
    pp_f("error: game ended\n");
    return true;
  }

  // Print the calculated evaluation of the AI.
  io_info();
  pp_f("evaluating...\n");

  move_t best_moves[256];
  eval_t eval =
      evaluate(&game_state, &game_history, global_options.ai_depth,
               global_options.ai_time, global_options.ai_tt_size, best_moves);

  io_info();
  pp_f("evaluating done\n");

  switch (evaluation_type) {
  case LIST:
    io_basic();
    pp_moves(best_moves);
    pp_f("\n");
    break;
  case RANDOM_MOVE:
    io_basic();
    size_t length = 0;
    while (is_valid_move(best_moves[length]))
      length++;
    pp_move(best_moves[rand() % length]);
    pp_f("\n");
    break;
  case EVAL_TEXT:
    io_basic();
    pp_eval(eval, game_state.board, &game_history);
    pp_f("\n");
    break;
  case FULL:
    io_basic();
    pp_moves(best_moves);
    pp_f(" -> ");
    pp_eval(eval, game_state.board, &game_history);
    pp_f("\n");
    break;
  }

  return true;
}

command_define(placeat, "Place a piece at a position",
               "Usage: placeat POS PIECE\n"
               "\n"
               "Place PIECE at POS.\n") {

  if (argc != 3) {
    io_error();
    pp_f("error: placeat requires exactly 2 arguments.\n");
    return false;
  }

  pos_t pos;
  if (!string_to_position(argv[1], &pos)) {
    io_error();
    pp_f("error: invalid position '%s'\n", argv[1]);
    return false;
  }

  piece_t piece = char_to_piece(argv[2][0]);
  if (!piece) {
    io_error();
    pp_f("error: invalid piece '%c'\n", argv[2][0]);
    return false;
  }

  place_piece(&game_state, &game_history, pos, piece);
  return true;
}

command_define(removeat, "Remove the piece at a position",
               "Usage: removeat POS\n"
               "\n"
               "Remove the piece at POS.\n") {

  if (argc != 2) {
    io_error();
    pp_f("placeat requires exactly 1 arguments.\n");
    return false;
  }

  pos_t pos;
  if (!string_to_position(argv[1], &pos)) {
    io_error();
    pp_f("error: invalid position '%s'\n", argv[1]);
    return false;
  }

  remove_piece(&game_state, &game_history, pos);
  return true;
}

command_define(aidepth, "Set the maximum allowed search depth of the AI",
               "Usage: aidepth [DEPTH]\n"
               "\n"
               "Set the search depth of the AI to DEPTH if DEPTH is given. "
               "Otherwise print.\n") {

  switch (argc) {
  case 1:
    io_basic();
    pp_f("%zu\n", global_options.ai_depth);
    return true;
  case 2:
    global_options.ai_depth = atoi(argv[1]);
    return true;
  default:
    io_error();
    pp_f("command 'aidepth' expects 0 or 1 argument.\n");
    return false;
  }
}

command_define(aitime, "Set the maximum allowed search time of the AI",
               "Usage: aidepth [TIME]\n"
               "\n"
               "Set the search depth of the AI to TIME if TIME is given. "
               "Otherwise print.\n"
               "TIME is in milliseconds.\n") {

  switch (argc) {
  case 1:
    io_basic();
    pp_f("%zu\n", global_options.ai_time.tv_sec * 1000 +
                      global_options.ai_time.tv_nsec / 1000000);
    return true;
  case 2: {
    long milliseconds = atoi(argv[1]);
    global_options.ai_time.tv_sec = milliseconds / 1000;
    global_options.ai_time.tv_nsec = (milliseconds % 1000) * 1000000;
    return true;
  }
  default:
    io_error();
    pp_f("command 'aidepth' expects 0 or 1 argument.\n");
    return false;
  }
}

static inline size_t count_branches(size_t depth) {
  if (!depth)
    return 1;

  // Check if reached a end of game node.
  if (game_state.status != NORMAL) {
    return 1;
  }

  // Count all of the nodes.
  size_t branches = 0;
  move_t moves[256];
  generate_moves(&game_state, moves);
  for (size_t i = 0; is_valid_move(moves[i]); i++) {
    do_move(&game_state, &game_history, moves[i]);
    branches += count_branches(depth - 1);
    undo_last_move(&game_state, &game_history);
  }

  return branches;
}

static inline void print_branches(size_t current_ply, size_t max_ply,
                                  move_t *branch) {
  if (current_ply >= max_ply) {
    branch[current_ply] = MOVE_INV;
    pp_moves(branch);
    pp_f("\n");
    return;
  }

  // Check if reached a end of game node.
  if (game_state.status != NORMAL) {
    branch[current_ply] = MOVE_INV;
    pp_moves(branch);
    pp_f(" %s\n", board_status_text(game_state.status));
    return;
  }

  // Count all of the nodes.
  move_t moves[256];
  generate_moves(&game_state, moves);
  for (size_t i = 0; is_valid_move(moves[i]); i++) {
    do_move(&game_state, &game_history, moves[i]);
    branch[current_ply] = moves[i];
    print_branches(current_ply + 1, max_ply, branch);
    undo_last_move(&game_state, &game_history);
  }

  return;
}

bool wait_for_child_resp(pid_t pid, char buffer[256], FILE *child_stdout) {
  fgets(buffer, 256, child_stdout);

  // This command does not accept very long outputs return error.
  if (strlen(buffer) == 255) {
    return true;
  }

  int status;
  waitpid(pid, &status, WNOHANG);

  return status && WIFEXITED(status);
}

command_define(
    test, "Run a test command",
    "Usage: test [OPTION]...\n"
    "\n"
    "Run a test command.\n"
    "\n"
    "  -l DEPTH      Count the number of reachable leaves in DEPTH ply.\n"
    "  -p DEPTH      Print all of the branches reachable in DEPTH ply.\n"
    "  -f EXEC       Play a game against another AI process with the same time "
    "and depth limits.\n "
    "  -n            Generate the n-tables and print the arrays.\n") {

  optind = 0;
  while (true) {
    int c = getopt(argc, argv, "l:p:f:n");
    switch (c) {
    case '?':
      return false;

    case 'n': {
      io_basic();
      pp_f("uint64_t n_table[4][64] = {\n");

      for (int delta = 0; delta < 4; delta++) {
        pp_f("  { ");
        for (int row = 0; row < 8; row++) {
          for (int col = 0; col < 8; col++) {
            uint64_t entry = 0;

            if (row - delta >= 0)
              entry |= 1ull << (((row - delta) << 3) + col);

            if (row + delta < 8)
              entry |= 1ull << (((row + delta) << 3) + col);

            if (col - delta >= 0)
              entry |= 1ull << ((row << 3) + col - delta);

            if (col + delta < 8)
              entry |= 1ull << ((row << 3) + col + delta);

            pp_f("0x%.16" PRIx64 ", ", entry);
          }
        }
        pp_f("},\n");
      }

      pp_f("};\n");
      break;
    }

    case 'f': {
      int child_stdin_fd[2];
      int child_stdout_fd[2];
      int child_stderr_fd[2];

      // Create pipe for stdin, stdout and stderr.
      if (pipe(child_stdin_fd) < 0) {
        io_error();
        pp_f("error: could not create pipe\n");
        return false;
      }

      if (pipe(child_stdout_fd) < 0) {
        io_error();
        pp_f("error: could not create pipe\n");
        return false;
      }

      if (pipe(child_stderr_fd) < 0) {
        io_info();
        pp_f("error: could not create pipe\n");
        return false;
      }

      pid_t pid = fork();
      switch (pid) {
      case -1:
        io_error();
        pp_f("error: could not fork child\n");
        return false;

      case 0: {
        // Child reads from the command pipe and writes to the return pipe.
        close(child_stdin_fd[1]);
        close(child_stdout_fd[0]);
        close(child_stderr_fd[0]);

        // Duplicate the pipes into the standard streams.
        dup2(child_stdin_fd[0], fileno(stdin));
        dup2(child_stdout_fd[1], fileno(stdout));
        dup2(child_stderr_fd[1], fileno(stderr));

        // Create the command strings using sprintf.
        char fen_buffer[256];
        get_fen_string(fen_buffer, &game_state);
        char loadfen_command[512];
        sprintf(loadfen_command, "loadfen '%s'", fen_buffer);

        char aitime_command[512];
        sprintf(aitime_command, "aitime %ld",
                global_options.ai_time.tv_sec * 1000 +
                    global_options.ai_time.tv_nsec / 1000000);

        char aidepth_command[512];
        sprintf(aidepth_command, "aidepth %zu", global_options.ai_depth);

        // Create the process.
        char *argv[] = {optarg, loadfen_command, aitime_command,
                        aidepth_command, NULL};

        execv(optarg, argv);

        io_error();
        pp_f("error: execv returned\n");

        close(child_stdin_fd[0]);
        close(child_stdout_fd[1]);
        close(child_stderr_fd[1]);
        exit(1);
      }

      default:
        // Parent writes to the pipe and reads from the return pipe.
        close(child_stdin_fd[0]);
        close(child_stdout_fd[1]);
        close(child_stderr_fd[1]);

        FILE *child_stdin = fdopen(child_stdin_fd[1], "a");
        FILE *child_stdout = fdopen(child_stdout_fd[0], "r");
        FILE *child_stderr = fdopen(child_stderr_fd[0], "r");

        char buffer[256];

        while (true) {
          // Before making any move, ask the child what the status is.
          // If it is different than ours, there is a problem.
          io_info();
          pp_board(game_state.board);
          pp_f("%s to move\n", game_state.turn ? "white" : "black");

          fprintf(child_stdin, "status\n");
          fflush(child_stdin);

          if (wait_for_child_resp(pid, buffer, child_stdout))
            break;

          // Hacky way to remove the newline character at the end of the buffer.
          buffer[strlen(buffer) - 1] = '\0';

          // If the status was different than expected report error.
          if (strcmp(board_status_text(game_state.status), buffer)) {
            io_error();
            pp_f("error: status from child does not match\n");
            break;
          }

          if (game_state.status != NORMAL) {
            io_info();
            pp_f("game ended\n");
            pp_f("%s\n", board_status_text(game_state.status));
            break;
          }

          move_t move;
          if (game_state.turn) {
            // If it is our turn to play, generate a random best move.
            move_t best_moves[256];
            evaluate(&game_state, &game_history, global_options.ai_depth,
                     global_options.ai_time, global_options.ai_tt_size,
                     best_moves);
            move = random_move(best_moves);

          } else {
            // If it is the child's turn to play, ask for a move.
            fprintf(child_stdin, "evaluate -r\n");
            fflush(child_stdin);
            if (wait_for_child_resp(pid, buffer, child_stdout))
              break;

            // Remove the newline character after the move.
            buffer[strlen(buffer) - 1] = '\0';

            // If the move was invalid report error.
            if (!string_to_move(buffer, game_state.board, &move)) {
              io_error();
              pp_f("error: invalid move from child, '%s'\n", buffer);
              break;
            }
          }

          io_info();
          pp_f("playing move: ");
          pp_move(move);
          pp_f("\n");

          // Make move and ask the child to make the move on their board as
          // well.
          do_move(&game_state, &game_history, move);
          fprintf(child_stdin, "makemove ");
          fprint_move(child_stdin, move);
          fprintf(child_stdin, "\n");
          fflush(child_stdin);
        }

        int status;
        waitpid(pid, &status, WNOHANG);
        if (WIFEXITED(status)) {
          pp_f("process exited with exit code %u\n", WEXITSTATUS(status));
        } else {
          kill(pid, SIGKILL);
          pp_f("killed process\n");
        }

        char buffer_stderr[256];
        io_debug();
        pp_f("error output from process:\n");
        while (true) {
          if (!fgets(buffer_stderr, 256, child_stderr))
            break;
          pp_f("%s", buffer_stderr);
        }
        pp_f("\n");

        fclose(child_stdin);
        fclose(child_stdout);
        fclose(child_stderr);
        return true;
      }
    }

    case 'l':
      io_basic();
      pp_f("%zu\n", count_branches(atoi(optarg)));
      return true;

    case 'p':
      io_basic();
      move_t moves[256];
      print_branches(0, atoi(optarg), moves);
      return true;

    case -1:
      return true;
    }
  }
}

command_define(help, "Get information about commands",
               "Usage: help [COMMAND]\n"
               "\n"
               "List commands or get information about COMMAND.\n") {

  io_basic();
  if (argc == 1) {
    pp_f("For more information on a command, use 'help COMMAND'\n\n");
    for (size_t i = 0; command_entries[i].function != NULL; i++) {
      const int message_x = 14;
      command_entry_t command = command_entries[i];
      pp_f("  %s", command.name);
      for (int i = 0; i < message_x - strlen(command.name); i++) {
        pp_f(" ");
      }
      pp_f("%s\n", *command.simple_description);
    }
    pp_f("\n");
    return true;
  }

  // Check for the command name in the command entries.
  for (size_t command_id = 0; command_entries[command_id].name != NULL;
       command_id++) {
    if (!strcmp(argv[1], command_entries[command_id].name)) {
      pp_f("\n%s\n", *command_entries[command_id].full_description);
      return true;
    }
  }

  io_error();
  pp_f("error: unknown command '%s'\n", argv[1]);
  return false;
}

#define command_entry(_name)                                                   \
  (command_entry_t) {                                                          \
    .name = #_name, .function = command_##_name,                               \
    .simple_description = &command_##_name##_simple,                           \
    .full_description = &command_##_name##_full,                               \
  }

command_entry_t command_entries[] = {
    command_entry(help),
    command_entry(show),
    command_entry(loadfen),
    command_entry(savefen),
    command_entry(makemove),
    command_entry(undomove),
    command_entry(automove),
    command_entry(status),
    command_entry(allmoves),
    command_entry(descmove),
    command_entry(placeat),
    command_entry(removeat),
    command_entry(aidepth),
    command_entry(aitime),
    command_entry(playai),
    command_entry(evaluate),
    command_entry(test),
    {
        NULL,
        NULL,
        NULL,
        NULL,
    },
};
